package uet.barrydevp.towerdefense.Monster;import uet.barrydevp.towerdefense.Game.GameManager;import uet.barrydevp.towerdefense.HealthBar;import uet.barrydevp.towerdefense.Sprite;import javafx.geometry.Point2D;import java.util.ArrayList;public abstract class BaseMonster {    /**     * Property     */    // public    private Sprite baseSprite;    private ArrayList<Point2D> pointsArray;    private boolean isAttackByTower;    private boolean isAttacking;    private float runSpeed;    private float maxHp;    private float curHp;    private float force;    private float armor;    private float hpPercentage;    private int money;    private final HealthBar hpBar;    // protected    protected  int pointCounter;    protected  boolean isSlowed;    protected MonsterState monsterState;    protected  MonsterState lastState;    protected MonsterName monsterName;    /**     * Constructor     */    public BaseMonster() {        baseSprite = null;        pointCounter = 0;        runSpeed = 0;        maxHp = 0;        curHp = 0;        armor = 0;        hpPercentage = 0;        hpBar = null;        lastState = null;        isAttackByTower = true;        isAttacking = false;        isSlowed = false;        money = 0;    }    public void setMonsterName(MonsterName monsterName) {        this.monsterName = monsterName;    }    public MonsterName getMonsterName() {        return monsterName;    }    public void setMonsterState(MonsterState monsterState) {        this.monsterState = monsterState;    }    public MonsterState getMonsterState() {        return monsterState;    }    public Sprite getBaseSprite() {        return baseSprite;    }    public void setBaseSprite(Sprite baseSprite) {        this.baseSprite = baseSprite;    }    public ArrayList<Point2D> getPointsArray() {        return pointsArray;    }    public void setPointsArray(ArrayList<Point2D> pointsArray) {        this.pointsArray = pointsArray;    }    public float getArmor() {        return armor;    }    public void setArmor(float armor) {        this.armor = armor;    }    public float getCurHp() {        return curHp;    }    public void setCurHp(float curHp) {        this.curHp = curHp;    }    public float getMaxHp() {        return maxHp;    }    public void setMaxHp(float maxHp) {        this.maxHp = maxHp;    }    public float getForce() {        return force;    }    public void setForce(float force) {        this.force = force;    }    public int getMoney() {        return money;    }    public void setMoney(int money) {        this.money = money;    }    public float getRunSpeed() {        return runSpeed;    }    public void setRunSpeed(float runSpeed) {        this.runSpeed = runSpeed;    }    public float getHpPercentage() {        return hpPercentage;    }    public void setHpPercentage(float hpPercentage) {        this.hpPercentage = hpPercentage;    }    public boolean isAttackByTower() {        return isAttackByTower;    }    public void setAttackByTower(boolean attackByTower) {        isAttackByTower = attackByTower;    }    public boolean isAttacking() {        return isAttacking;    }    public void setAttacking(boolean attacking) {        isAttacking = attacking;    }    public boolean isSlowed() {        return isSlowed;    }    public void setSlowed(boolean slowed) {        isSlowed = slowed;    }    /**     * method     */    // public    public abstract boolean init();    public void getHurt(){        // doi mau khi bi ban trung    }    public void death(){    }    public void explosion(){    }    public void stopWalking(){    }    public void restartWalking(){    }    public void slowRunSpeed(float dt, float dis){    }    public Point2D getNextPoint(){        int maxCount = pointsArray.size();        if(++pointCounter < maxCount) {            return pointsArray.get(pointCounter--);        }        --pointCounter;//        System.out.println("nextpointCounter: " + pointCounter);        return curPoint();    }    public void frozen(){    }    public void refrozen(float dt){    }    // protected    protected void setMonsterZorder(int yOrder){    }    protected Point2D curPoint(){        return pointsArray.get(pointCounter);    }    protected Point2D getCurPoint(){//        System.out.println("curpointCounter: " + pointCounter);        return pointsArray.get(pointCounter);    }    protected Point2D getCenterLocation(){        return baseSprite.getCenterLocation();    }    protected void setCenterLocation(Point2D p){        baseSprite.setCenterLocation(p);    }//    protected Point2D nextPoint(){//        int maxCount = pointsArray.size();//        if(++pointCounter < maxCount) {//            return pointsArray.get(pointCounter);//        }//        --pointCounter;////        return curPoint();//    }    protected void nextPoint(){        int maxCount = pointsArray.size();        if(++pointCounter > maxCount) {            --pointCounter;        }    }    public void runNextPoint(double elapsedTime){//        System.out.println(elapsedTime);        Point2D tempCurPoint = getCurPoint();//        baseSprite.setPosition(tempCurPoint);        Point2D tempNextPoint = getNextPoint();//        setMonsterZorder();        if(tempNextPoint.getY() > tempCurPoint.getY())        {            monsterState = MonsterState.stateWalkUp;        }else if(tempNextPoint.getY() <= tempCurPoint.getY())        {            monsterState = MonsterState.stateWalkDown;        }else if(tempNextPoint.getX() >= tempCurPoint.getX())        {            monsterState = MonsterState.stateWalkRight;        }        else if(tempNextPoint.getX() < tempCurPoint.getX())        {            monsterState = MonsterState.stateWalkLeft;        }        // monster move        if(tempNextPoint != tempCurPoint ){//            System.out.println("pointCounter: " + pointCounter);            Point2D centerLocation = getCenterLocation();            double ds = tempNextPoint.distance(centerLocation);//            System.out.println("ds:" + ds);//            System.out.println("v * time:" + runSpeed * elapsedTime);//            System.out.println(runSpeed * elapsedTime > ds);            if((runSpeed * elapsedTime) > ds) {                nextPoint();            }            Point2D vectorVelocity = tempNextPoint.subtract(centerLocation);            double alpha = Math.atan2(vectorVelocity.getY(), vectorVelocity.getX());            double velocityX = runSpeed * Math.cos(alpha);            double velocityY = runSpeed * Math.sin(alpha);            double dx = velocityX * elapsedTime;            double dy = velocityY * elapsedTime;            Point2D s = new Point2D(dx, dy);//            System.out.println(dx);            setCenterLocation(centerLocation.add(s));            baseSprite.setR(Math.toDegrees(alpha));//            System.out.println(baseSprite.getDrawLocation());            baseSprite.updateUI();        } else{            GameManager.getInstance().setLife(GameManager.getInstance().getLife() - 1);            GameManager.getInstance().removeMonster(this);            curHp = 0;            baseSprite.removeFromLayer();        }    }    protected void createAndSetHpBar(){    }//    protected boolean onTouchBegan();//    protected void onTouchEnded();    protected void update(float dt){    }    protected void stopMonsterAnimation(){    }    protected void showInfo(){    }    protected void setListener(){    }}